---
title: "Data Visualization with ggplot"
output:
        html_document:
            includes:
                in_header: header.html
            theme: paper
            toc: true
            toc_depth: 4
            toc_float: true
            number_sections: false
            fig_caption: false
            markdown: GFM
            code_download: false
---

<style type="text/css">

body, td {
   font-size: 16px;
}
code.r{
  font-size: 12px;
}
pre {
  font-size: 12px
}

</style>

```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy(lang = c("r", "markdown", "bash"), position = c("top", "right"))
```

```{r, 'chunk_options', include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("03-")
```

# Objectives

- Create plots with both discrete and continuous variables with `ggplot2`.
- Understand the mapping of data to attributes / components of the graph.
- Modify the color, theme, and axis labels of a plot.

# Exploring data visually

We have learned how to use functions from the `tidyverse` to subset and summarize data, along with some of the equivalent base R functions. But all of our manipulations have lacked the visual component that can be so helpful in understanding the properties of data, i.e. distributions, outliers, trends, etc. Let's turn our attention to plotting in the `tidyverse` with `ggplot2`.

The intellectual framework for `ggplot2` comes from the "Grammar of Graphics" by Wilkinson ([ref](https://link.springer.com/book/10.1007/0-387-28695-0)). This module will introduce the components of that grammar, and how to combine them into publication-ready plots.

## Loading data

In the previous lesson we used the `read_csv()` function to load the `gm97` data. Let's do that again:

```{r, 'load_gm97_display', eval = FALSE}
library(tidyverse)
gm97 = read_csv('data/gapminder_1997.csv')
```

```{r, 'load_gm97', echo = FALSE}
library(tidyverse)
gm97 = read_csv('../data/gapminder_1997.csv')
```

## Mappings, aesthetics, and geometries

Let's jump right in and create our first plot using the `ggplot()` function. Along the way we'll discuss the components of a plot, and how `ggplot2` conceptualizes plotting.

```{r, 'plot1'}
ggplot(data = gm97)
```

When we ran this code the Plots tab popped up and displayed ... a gray rectangle. This is underwhelming as a first plot, but it's a helpful reminder that computers do exactly what we tell them. In this case, we've just told R that we want to plot data from `gm97`. We haven't told it **how**.

The elements of a plot have properties like: x and y position, size, color, etc. These properties are **aesthetics**, and we need to map variables in our dataset to aesthetics in our plot. This is done with the aesthetic mapping function `aes()`. Let's build up our plot iteratively by mapping `gdpPercap` to the x-axis with:

```{r, 'plot2'}
ggplot(data = gm97) +
    aes(x = gdpPercap)
```

In `ggplot2`, the `+` indicates we want to add elements to a plot; it's kind of like the pipe (`%>%`) in `dplyr`. Our plot window is no longer a blank gray square, but now has a labeled x-axis with visual delimiters. Here, `gdpPercap` is just the column name from our data, and isn't really formatted in a "publication-ready" manner. We can use the `labs()` function to alter the label on the x-axis with:

```{r, 'plot3'}
ggplot(data = gm97) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita')
```

**Checkpoint**

> ## Exercise
> How would we map life expectancy to the y-axis and give it a nicer label?
> 
> ```{r, 'plot4'}
> ggplot(data = gm97) +
>     aes(x = gdpPercap) +
>     labs(x = 'GDP Per Capita') +
>     aes(y = lifeExp) + 
>     labs(y = 'Life Expectancy')
> ```
> 

This is progress, but we still don't have any data plotted. For this, we tell the plot object what to draw by adding a **geometry** (or `geom` for short). There are many geometries, but we'll begin with `geom_point()`, which plots points in the x-y plane.

```{r, 'plot5'}
ggplot(data = gm97) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point()
```

From the plot, it appears that higher GDP correlates with longer life expectancy. We can add a title to the plot with `labs()` to suggest this is the point of the plot:

```{r, 'plot6'}
ggplot(data = gm97) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point() +
    labs(title = 'Do people in wealthier countries live longer?')
```

**Checkpoint**

## Color

We've made excellent progress on our first plot, and without even having to write very much code! There is much more we can do visually to understand what the data might be telling us in addition to the general trend we've already observed. For example, we can use different colors for each continent to understand how continent affects this relationship:

```{r, 'plot_color_continent'}
ggplot(data = gm97) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point() +
    labs(title = 'Do people in wealthier countries live longer?') + 
    aes(color = continent)
```

With the continents shown by color, we immediately pick out that African countries tend to have lower life expectancy than other countries. Of course, there are African countries (red points) with life expectancies similar to wealthier countries, suggesting that GDP per capita does not tell the full story about health, as we might have already guessed.

**Checkpoint**

## Scale

When we added the color mapping, ggplot added a legend automatically, assigning different colors to each of the unique values of `continent`. The colors ggplot uses are considered a "scale," and each aesthetic value we can give (x, y, color, etc) has a corresponding scale. Let's experiment with a different numerical scale to see how that works.

```{r, 'plot_x_log_scale'}
ggplot(data = gm97) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point() +
    labs(title = 'Do people in wealthier countries live longer?') + 
    aes(color = continent) + 
    scale_x_log10()
```

Here we see that the x-axis has been scaled by the log10. Depending on the data we're plotting the log scale might be more appropriate than the default linear scale. We can also change the scale on the `continent` mapping to change the colors:

```{r, 'plot_color_continent_set1'}
ggplot(data = gm97) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point() +
    labs(title = 'Do people in wealthier countries live longer?') + 
    aes(color = continent) + 
    scale_color_brewer(palette = 'Set2')
```

In this case, `Set2` palette is color-blind friendly. There are many built-in palettes:

```{r, 'brewer_pal_info'}
RColorBrewer::display.brewer.all()
```

Note that there are linear color scales which might be appropriate for numerical data with a minimum value of 0 (top group). There are also discrete color scales more appropriate for categorical data that aren't associated with magnitude, like `continent` (middle group). There are also divergent color scales that might be useful for continuous variables centered around 0 (bottom group).

Additionally, we can view attributes of the palettes, including which are color-blind friendly, with:

```{r, 'brewer_pal_info2'}
RColorBrewer::brewer.pal.info
```

The RColorBrewer package is an excellent package for its ready-made palettes, as well as the ability to create custom palettes. See 

**Checkpoint**

## Size

We also have the population data for each country and we might wonder if population has an effect on life expectancy and GDP per capita. We can map `pop` to the size of the points in the plot by adding another `aes()`. If there was a relationship, we might expect to see larger points concentrated in certain regions of the resulting graph.

> ## Exercise
> 
> Given our previous code mapping data columns to the axes and to color, what would we add to the previous plot code to map the population to the `size` aesthatic?
> 
> ```{r, 'plot_pop_size'}
> ggplot(data = gm97) +
>     aes(x = gdpPercap) +
>     labs(x = 'GDP Per Capita') +
>     aes(y = lifeExp) + 
>     labs(y = 'Life Expectancy') +
>     geom_point() +
>     labs(title = 'Do people in wealthier countries live longer?') + 
>     aes(color = continent) + 
>     scale_color_brewer(palette = 'Set1') +
>     aes(size = pop)
> ```
> 

Here ggplot has created another legend for us called `pop`, the name of the column, and it shows the size related to the population. However, this is in scientific notation, which is a little difficult to interpret at a glance. We can change this by dividing all the population values by 1,000,000. We can also change the labels of the legend using the `labs()` function, just as we did for the x and y axes and title.

```{r, 'plot_per_million'}
ggplot(data = gm97) +
    aes(x = gdpPercap) +
    labs(x = 'GDP Per Capita') +
    aes(y = lifeExp) + 
    labs(y = 'Life Expectancy') +
    geom_point() +
    labs(title = 'Do people in wealthier countries live longer?') + 
    aes(color = continent) + 
    scale_color_brewer(palette = 'Set1') +
    labs(color = 'Continent') +
    aes(size = pop/1000000) + 
    labs(size = 'Population (in millions)')
```

From this plot, it doesn't look like population has much to do with either life expectancy or GDP per capita. Notice in the `aes()` with `size` we divided the `pop` column by 1,000,000. This works because columns in aesthetic mappings can be treated just like any other variable, and we can use functions to transform or change them at plot time rather than transforming the data first. We will see later that for more complex transformations, it can be advantageous to transform the data first and build a plot based on the transformed data rather than doing it at plot time.

**Checkpoint**

## Compact code

In this lesson we have built our plot up line by line and accumulated many lines of code. Many of these steps can be combined to make the code a bit more compact and readable:

```{r, 'plot_compact_code'}
ggplot(data = gm97) + 
    aes(x = gdpPercap, y = lifeExp, color = continent, size = pop/1000000) + 
    geom_point() + 
    scale_color_brewer(palette = 'Set1') + 
    labs(x = 'GDP Per Capita', y = 'Life Expectancy', color = 'Continent', size = 'Population (in millions)',
         title = 'Do people in wealthier countries live longer?')
```

**Checkpoint**

## Exploring more complex data

The `gm97` has been useful for exploring `dplyr` and `ggplot` functions. Let's load in a more complex dataset so we have a bit more data to explore. The `data/gapmainder_data.csv` dataset is similar to `gm97`, but is longitudinal. The first step is to load in the data.

```{r, 'load_gapminder_display', eval = FALSE}
gm = read_csv('data/gapminder_data.csv')
```

```{r, 'load_gapminder', echo = FALSE}
gm = read_csv('../data/gapminder_data.csv')
```

Let's look at a preview of the data and explore some functions to see its attributes. First, we can preview it by evaluating a line of code which just names the object:

```{r, 'preview_gapminder'}
gm
```

**Checkpoint**

Again, the `tibble` provides a nice preview of the data along with many of the attributes including the dimensions and types of columns. There are some functions we can use to determine these attributes on their own:

```{r, 'dim'}
dim(gm)
```

This gives us the number of rows and columns, respectively.

```{r, 'head'}
head(gm)
tail(gm)
```

The `head()` and `tail()` functions display the first and last few rows of an object, respectively. There is also a useful function called "structure", `str()`, which displays the structure of an object. This is especially useful when we don't know what an object contains.

```{r, 'str'}
str(gm)
```

This is similar to information we see in the `tibble` preview. We see the type of object, dimensions, columns, their type, and a preview of their values. Of course, the `summary()` function works just the same as it did for `gm97`, and it's a good idea to take a peek and see what the range of the data are:

**Checkpoint**

```{r, 'gapminder_summary'}
summary(gm)
```

We see the same columns as `gm97` but we notice that there are many more years of data collected than just 1997. Let's jump right in with a plot to understand what this data looks like. And let's begin with something similar to the scatterplot we did for `gm97`, but include the year.

```{r, 'full_plot_point'}
ggplot(data = gm) +
    aes(x = year, y = lifeExp, color = continent) + 
    geom_point()
```

There seems to be an overall trend of higher life expectancy over time, but it's not as clear as it could be. In our plot, the country-level data is not connected, making it hard to understand country-level trends. Before we figure out how to connect the dots, let's use our `dplyr` knowledge to see if that overall trend we suspect is correct.

```{r, 'summarize_lifeexp_over_years'}
gm %>% group_by(year) %>% summarize(mean_life_exp = mean(lifeExp))
```

That seems clear enough. Of course, this is for all countries combined. We could add continent as an additional group:

```{r, 'summarize_lifeexp_over_years_continents'}
gm %>% group_by(year, continent) %>% summarize(mean_life_exp = mean(lifeExp))
```

> ## Exercise
> 
> The above code is ordered by year, but to see the continent-wise trend, it would be easier to see the data arranged by continent, how would we rearrange the rows by continent?
> 
> ```{r, 'summarize_lifeexp_over_years_continents2'}
> gm %>% 
>     group_by(year, continent) %>% 
>     summarize(mean_life_exp = mean(lifeExp)) %>% 
>     arrange(continent)
> ```
> 

This is a step in the right direction, but now the `tibble` preview is actually preventing us from seeing all the data. There are two ways we can see the full result:

```{r, 'view'}
life_exp_by_year_continent = gm %>% 
    group_by(year, continent) %>% 
    summarize(mean_life_exp = mean(lifeExp)) %>% 
    arrange(continent)
```

```{r, 'view_no_eval', eval = FALSE}
View(life_exp_by_year_continent)
```

The `View()` function will show the table in the Scripts pane. Another way to accomplish this is to `%>%` pipe `life_exp_by_year_continent` as a `data.frame`:

```{r, 'data.frame'}
life_exp_by_year_continent %>% data.frame
```

<!-- Might also consider the pivot functions here... -->

And the result is printed out in the Console pane. Either way, the trend of increasing life expectancy over time that we saw globally appears to hold across all continents as well. 

**Checkpoint**

## Line geometry

Of course, **seeing** this data would be more compelling, and we already went through the trouble to save the summarized data as its own object, so let's use it to introduce the line geometry `geom_line()`.

```{r, 'plot_lifeexp_line'}
ggplot(life_exp_by_year_continent) + 
    aes(x = year, y = mean_life_exp, color = continent) + 
    geom_line()
```

The `geom_line()` geometry connects the data points across time in the appropriate way. Sure enough, we see what we noticed from looking at the summarized table. This is a good example of needing to summarize the data before plotting, rather than altering the data at runtime, as we did when we divided the population by 1,000,000.

Let's pull this plot back a bit and try to plot all the countries at the same time, rather than an average. Let's try altering the code above and replace `geom_point()` with `geom_line()`:

```{r, 'full_plot_line_wrong'}
ggplot(data = gm) +
    aes(x = year, y = lifeExp, color = continent) + 
    geom_line()
```

This is definitely not the right thing. We got a line for each continent, but we want a line for each country. To tell `ggplot` to connect the values for each `country`, we use the `group` aesthetic:

```{r, 'full_plot_line_correct'}
ggplot(data = gm) +
    aes(x = year, y = lifeExp, color = continent, group = country) + 
    geom_line()
```

And now we see each country plotted as its own line so we can see the overall trend, as well as the deviations from the trend.

**Checkpoint**

## Geometries for categories

The `geom_point` and `geom_line` geometries are designed to display numeric values on the x and y axes. Often data has discrete variables (`continent` or `country`) where something like a box plot is more appropriate. Let's revisit our `gm97` data to create a box plot with the continent on the x axis and the life expectancy on the y-axis.

```{r, 'plot_box'}
ggplot(data = gm97) + aes(x = continent, y = lifeExp) + geom_boxplot()
```

This makes comparing the range and spread of values across groups easier. The median of the data is displayed, as is the 25% and 75%-iles and any outliers.

**Checkpoint**

## Factors

In the above box plots it's perfectly acceptable to have the continents listed in alphabetical order, which is the default when plotting categorical data in `ggplot2`. Imagine, however, that we want a box plot with months on the x-axis and some data on the y-axis. It wouldn't be appropriate to plot the months in alphabetical order. Fortunately there is a data type in R called a **factor** which stores categorical data and enables us to specify the order of the "levels" or categories.

We know that our data has a `continent` column, and we saw before that there were only 5 unique values in this column. This is a perfect candidate to introduce the idea of a factor. Let's `mutate()` the `gm97` data and add a factor version of the continent column. 

First, let's look at `?factor`. It takes a character vector (exactly what the `continent` column is), and an optional `levels` character vector which dictates the categories and their desired order.

```{r, 'factor1'}
gm_factor = gm97 %>% 
    mutate(continent_factor = factor(continent, levels = c('Oceania', 'Africa', 'Asia', 'Americas', 'Europe')))
```

Let's take a look at the new object and see how it's different.

```{r, 'factor_preview'}
gm_factor
```

Note that the new column has type `fct` (factor) and the old has `chr` (character). That's a good start. Let's look at the head of both columns.

```{r, 'head_continent'}
head(gm_factor$continent)
head(gm_factor$continent_factor)
```

**Checkpoint**

Notice that for the factor column we get the same output, but with additional information about the `levels`, and the ordering is exactly what we specified. Now let's see the effect on a plot similar to the boxplot we already created above.

```{r, 'factor_boxplot'}
ggplot(data = gm_factor) + aes(x = continent_factor, y = lifeExp) + geom_boxplot()
```

Compare this to the plot we saw with the `continent` column, where the order was alphabetical. In the RNA-seq Demystified Workshop we will also see how factors and the order of their levels affect the tests for differential expression.

**Checkpoint**

## Layers (optional)

To get a sense for how the data are distributed in the box plot, we could add a **layer** with `geom_point()` in addition to `geom_boxplot()`.

```{r, 'plot_box_layer'}
ggplot(data = gm97) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot() + 
    geom_point()
```

The points are stacking on top of one another, and it can be hard to tell, for a value of `lifeExp`, if more than one data point is there. We can fix this by "jittering" the points, with `geom_jitter()`.

```{r, 'plot_box_jitter'}
ggplot(data = gm97) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot() + 
    geom_jitter()
```

Within a column, the horizontal position doesn't have meaning, and is meant to visually separate points of the same value. However, it feels like the jitter is a bit wide, causing the boundaries between the continents to be unclear. If we look at the help `?geom_jitter` we'd see a `width` parameter, which controls how wide to allow the jitter.

```{r, 'plot_box_jitter_width'}
ggplot(data = gm97) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot() + 
    geom_jitter(width = 0.15)
```

It may take some iterations of the `width` parameter to get things where we want them. This is pretty common in `ggplot2`. Note that the word "layer" also means that the layers appear in a particular order, for example, if we swap the `geom_boxplot()` and `geom_jitter()` we see that the points are obscured.

```{r, 'plot_box_jitter_layer'}
ggplot(data = gm97) + 
    aes(x = continent, y = lifeExp) + 
    geom_jitter(width = 0.15) +
    geom_boxplot()
```

Using the `width` parameter in `geom_jitter()`, we saw that it was possible to change aspects of a layer without altering other layers. This carries into the aesthetics too. For example, if we wanted to add a `size` aesthetic using the `pop` to only the `geom_jitter()` layer:

```{r, 'plot_box_jitter_aes'}
ggplot(data = gm97) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot() + 
    geom_jitter(aes(size = pop), width = 0.3)
```

**Checkpoint**

## Color and Fill (optional)

Let's have a look at our jittered boxplot and explore `color` and `fill`. When a color is assigned directly, we use the name of the color in quotes, as in 'pink', and we don't need to use the `aes()` function.

```{r, 'plot_box_color1'}
ggplot(data = gm97) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot(color = 'pink') + 
    geom_jitter(aes(size = pop), width = 0.3)
```

We could add a different color to the points in the `geom_jitter()`, and we would do it outside of the `aes()` if we wanted them to be the same.

```{r, 'plot_box_color2'}
ggplot(data = gm97) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot(color = 'pink') + 
    geom_jitter(aes(size = pop), color = 'blue', width = 0.3)
```

Notice that `color` changed the outline of the `geom_boxplot()`. We would use `fill` if we wanted to change the inside color of the box plot.

```{r, 'plot_box_color3'}
ggplot(data = gm97) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot(color = 'pink', fill = 'green') + 
    geom_jitter(aes(size = pop), color = 'blue', width = 0.3)
```

We probably won't publish this particular plot, as beautiful as it is.

We have already seen in other plots that we can link `color` to an attribute of our data. We can do the same with `fill`, but we do it inside of the `aes()` function.

```{r, 'plot_box_color4'}
ggplot(data = gm97) + 
    aes(x = continent, y = lifeExp) + 
    geom_boxplot(aes(fill = continent)) + 
    geom_jitter(aes(size = pop), width = 0.3)
```

**Checkpoint**

## Single-variable plots

Our very first plot involved two variables, but it's often helpful to plot a single variable's values as a histogram to understand its distribution. Here the geometries `geom_histogram()` and `geom_density()` can help us. Let's take a look at the histogram for `lifeExp`.

```{r, 'plot_histogram'}
ggplot(data = gm97) +
    aes(x = lifeExp) + 
    geom_histogram()
```

Here there is a message displayed that the default number of bins is 30 from `geom_histogram()`, but that may not be appropriate for all data. There are two ways we can change the bins the geometry uses to count, `bins` which fixes the number of bins, and `binwidth` which fixes the intervals in which values are counted. Let's change the number of bins to 20.

```{r, 'plot_histogram_bins'}
ggplot(data = gm97) +
    aes(x = lifeExp) + 
    geom_histogram(bins = 20)
```

We can see there are fewer bins in this plot.

**Checkpoint**

## Facets

We have used the aesthetics `aes()` to map data to `color`, `fill`, etc. and distinguish differences between the subgroups. Faceting is another technique to plot subgroups in their own panels of a single plot, also helping to distinguish differences between subgroups. We started off a relatively simple plot of GDP per capita versus life expectancy, and later colored it by continent. But let's use facets to split the continents into their own sub-plots.

```{r, 'plot_scatter_facetwrap'}
ggplot(gm97) + 
    aes(x = gdpPercap, y = lifeExp) + 
    geom_point() + 
    facet_wrap(vars(continent))
```

Importantly, we had to use the helper function `vars()` to tell `facet_wrap()` what the column name to use in the facet. The details about why `vars()` is needed are somewhat nuanced, so we won't get into them, but know that some `ggplot2` and `dplyr` functions may require the use of `vars()` when giving column names, whereas in the `aes()` function we don't need the `vars()`.

It might be easier to compare differences in the sub-plots if they were arranged by row or by column, rather than wrapping them in a grid. Have a look at the help for `?facet_grid()`. There are `rows` and `cols` arguments that will display the facets as rows or columns.

```{r, 'plot_scatter_facetgrid'}
ggplot(gm97) + 
    aes(x = gdpPercap, y = lifeExp) + 
    geom_point() + 
    facet_grid(rows = vars(continent))
```

Now there is only one x-axis, and multiple y-axes. Here the scale is the same for all the y-axes to make them comparable, but there are parameters of `facet_grid()` that allow the scales to change depending on the data within the facet itself if that's more appropriate.

**Checkpoint**

# Saving plots

While it's great to keep the code that created the plot in an R script, it's also great to save it as an image so you can share it with people that don't use R, or don't want to run all your code to generate the plot. Since we're saving all our steps in a script, we'll make use of the `ggsave()` function. Let's start by taking a look at the help:

~~~
?ggsave
~~~

Note that it defaults to saving the last displayed plot. also note that there are parameters for the dimensions, the units of the dimensions, and the resolution. Let's run a very basic version of `ggsave()`.

```{r, 'ggsave1', eval = FALSE}
ggsave('first_saved_plot.png', height = 6, width = 6, dpi = 300)
```

**Checkpoint**

We can then navigate to the plot and click to open it in the File pane. Note that R Studio Server let's you easily download any file by clicking any number of checkboxes for the files and then clicking "More" and "Export". In the previous command we've used the `.png` extension, so that `ggsave()` knows to create a PNG, but we could have also used `.jpeg`, `.pdf`, `.eps`, etc to create an appropriate file output. See the documentation for `ggsave()` for supported file formats, and note that this is an easy way to save multiple formats and resolutions depending on whether you want to quickly share with a collaborator, or share with a journal for publication.

We just learned how to save plots as files, but we can also save plots as objects in R. This is helpful for when we want to revisit a plot or make changes to it without having to re-type a bunch of code.

```{r, 'plot_object'}
scatter_plot = ggplot(data = gm97) + 
    aes(x = gdpPercap, y = lifeExp, color = continent, size = pop/1000000) + 
    geom_point() + 
    scale_color_brewer(palette = 'Set1') + 
    labs(x = 'GDP Per Capita', y = 'Life Expectancy', color = 'Continent', size = 'Population (in millions)',
         title = 'Do people in wealthier countries live longer?',
         caption = 'Figure: GDP per capita and life expectancy are positively correlated, while population is not.')
```

Notice nothing happens, unlike when we ran the code without saving it as an object. If we want to see the plot again, we have to execute the name of the object:

```{r, 'display_plot_object'}
scatter_plot
```

**Checkpoint**

# Customizing plots

Now that we have a nice plot saved as an object, it's a good time to explore different customizations we can add to the plot. Let's start with changing the theme.

```{r, 'change_theme'}
scatter_plot + theme_bw()
```

What did this do? It changed the background color, added a border around the plot area, and perhaps some other things that are too subtle to notice. There are many themes available as presets ([see this link](https://ggplot2.tidyverse.org/reference/ggtheme.html)), but we can also more finely control aspects of our plot with the `theme()` function ([see documentation here](https://ggplot2.tidyverse.org/reference/theme.html) or do `?theme`).

## Change font attributes

We can use the `text` argument of `theme()` to change the size of all the fonts in the plot.

```{r, 'change_font_size'}
scatter_plot + theme(text = element_text(size = 16))
```

We could also rotate the axis labels using either the `axis.text.x` or `axis.text.y` parameter of `theme()`, and then the `angle`, `vjust`, and `hjust` parameters of `element_text()`.

```{r, 'rotate_labels'}
scatter_plot + theme(axis.text.x = element_text(angle = 90))
```

Here the axis labels aren't centered on the ticks, and seem to be center justified. We use the `vjust` and `hjust` parameters to fix that. This is a case where an example from searching the internet was helpful.

```{r, 'rotate_labels2'}
scatter_plot + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```

**Checkpoint**

## Labeling points (optional)

In the scatterplot, we might want to highlight certain countries, such as Brazil, China, India, and the United States. There is a very nice add-on package called [`ggrepel`](https://ggrepel.slowkow.com/index.html). In particular, if we look at the example for [how to hide some of the labels](https://ggrepel.slowkow.com/articles/examples.html#hide-some-of-the-labels), we'll get a sense for how to write code to highlight these countries.

It seems like we'll need to add a new column to `gm97` that has empty labels (`''`) for the countries other than Brazil, China, India, and the United States.

```{r, 'modify_gapminder'}
library(ggrepel)

gm97_labels = gm97 %>% 
    mutate(label = ifelse(country %in% c('Brazil', 'China', 'India', 'United States'), country, ''))
```

What have we done here? We've used the `mutate()` function to create a new column called label, and the criteria for the entries are, if the entry from the `country` column is in the set `c('Brazil', 'China', 'India', 'United Staets')`, then pass on the country name, otherwise give it an empty string `''`. How can we be sure that we've done the right thing?

```{r, 'check_label1'}
gm97_labels
```

Looks like the labels in the preview are correct, how can we check that the countries we wanted are correct?

```{r, 'check_label2'}
gm97_labels %>% filter(label != '')
```

So now let's take a cue from the example code and incorporate it into our original code:

```{r, 'plot_labels'}
ggplot(data = gm97_labels) + 
    aes(x = gdpPercap, y = lifeExp, color = continent, size = pop/1000000, label = label) + 
    geom_point() + 
    geom_text_repel(box.padding = 0.5, max.overlaps = Inf) +
    scale_color_brewer(palette = 'Set1') + 
    labs(x = 'GDP Per Capita', y = 'Life Expectancy', color = 'Continent', size = 'Population (in millions)',
         title = 'Do people in wealthier countries live longer?',
         caption = 'Figure: GDP per capita and life expectancy are positively correlated, while population is not.')
```

**Checkpoint**

Notice that the size of the label is actually inherited from the size aesthetic. This is an example of aesthetics being inherited by default. We could prevent this inheritance by moving the `color` and `size` aesthetic mappings into `geom_point()` so that they only apply to that layer:

```{r, 'plot_labels2'}
ggplot(data = gm97_labels) + 
  aes(x = gdpPercap, y = lifeExp, label = label) + 
  geom_point(aes(color = continent, size = pop/1000000)) + 
  geom_text_repel(box.padding = 0.5, max.overlaps = Inf) +
  scale_color_brewer(palette = 'Set1') + 
  labs(x = 'GDP Per Capita', y = 'Life Expectancy', color = 'Continent', size = 'Population (in millions)',
       title = 'Do people in wealthier countries live longer?',
       caption = 'Figure: GDP per capita and life expectancy are positively correlated, while population is not.')
```

# Objectives

- Learn the essential parts of the `ggplot2` "grammar of graphics":
    - Map variables from the data to aesthetics (x, y, color, fill, size, etc.) via `aes()`.
    - Plot those mappings with geometries via `geom_*()`.
    - Adjust numeric and categorical scales via `scale_*()`.
    - Use a variable to visually stratify data via `facet_*()`.
- Learn how to customize plots by:
    - Changing color and fill with the RColorBrewer package.
    - Altering text and formatting of axis labels and legends.

# Exercise
> 
> In a previous exercise we created a plot showing the trend of life expectancy across all countries over time, colored by the continent. The following code generates a similar plot but for the GDP per capita.
> 
> ```{r, 'ggplot_exercise_example'}
> ggplot(data = gm, aes(x = year, y = gdpPercap, color = continent, group = country)) +
>     geom_line() + theme_bw() +
>     labs(
>         title = 'GDP per Capita 1952 - 2007',
>         x = 'Year', y = 'GDP per Capita')
> ```
> Is this plot clear? Might it be improved by splitting up the continents into their own plots? Below is a plot which pulls apart the trends on the different continents, while still plotting each country individually. Try to write the code that would generate it.
> 
> ```{r, 'ggplot_exercise', echo = FALSE}
> ggplot(data = gm, aes(x = year, y = gdpPercap, color = continent, group = country)) +
>     geom_line() + facet_grid(cols = vars(continent)) +
>     labs(
>         title = 'GDP per Capita 1952 - 2007',
>         x = 'Year', y = 'GDP per Capita') +
>     theme_bw() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
> ```
> 
> This plot generates a lot of questions. For example:
> 
> 1. What is the Asian country with the very high GDP per capita?
> 2. What are the two countries that are outliers in the Americas?
> 3. What two African countries seemed to experience strong GDP per capita growth through 1980, only to drop off?
> 4. What two European countries overtake the long-leading GDP per capita country in 2007?
> 
> All of these questions are suggested by looking at the plot, but we can answer them with the `dplyr` functions we've learned.
> 
> 1. To find the Asian country of interest, we could simply find the country with the highest GDP per capita in 1952.
> 
> ```{r, 'exercise_1'}
> gm %>% filter(year == 1952) %>% arrange(desc(gdpPercap))
> ```
> 
> 2. We can actually use a similar tactic for this question, but we can pick any year based on the plot, and we must filter on the correct continent. Then we can observe the top two rows.
> 
> ```{r, 'exercise_2'}
> gm %>% filter(year == 2007 & continent == 'Americas') %>% arrange(desc(gdpPercap))
> ```
> 
> 3. We can use a similar approach as 2, but filter on the African countries, and look at the top two results.
> 
> ```{r, 'exercise_3'}
> gm %>% filter(year == 1977 & continent == 'Africa') %>% arrange(desc(gdpPercap))
> ```
>
> 4. And again, but look at the top three results.
> 
> ```{r, 'exercise_4'}
> gm %>% filter(year == 2007 & continent == 'Europe') %>% arrange(desc(gdpPercap))
> ```
> 

<br/>
<br/>
<hr/>
| [Previous lesson](r-05-help.Rmd) | [Top of this lesson](#top) | [Wrap up](workshop-wrap-up.html) |
| :--- | :----: | ---: |